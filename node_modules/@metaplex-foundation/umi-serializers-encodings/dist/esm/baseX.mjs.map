{"version":3,"file":"baseX.mjs","sources":["../../src/baseX.ts"],"sourcesContent":["import type { Serializer } from '@metaplex-foundation/umi-serializers-core';\nimport { InvalidBaseStringError } from './errors';\n\n/**\n * A string serializer that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create serializers such as base10 or base58.\n *\n * @category Serializers\n */\nexport const baseX = (alphabet: string): Serializer<string> => {\n  const base = alphabet.length;\n  const baseBigInt = BigInt(base);\n  return {\n    description: `base${base}`,\n    fixedSize: null,\n    maxSize: null,\n    serialize(value: string): Uint8Array {\n      // Check if the value is valid.\n      if (!value.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new InvalidBaseStringError(value, base);\n      }\n      if (value === '') return new Uint8Array();\n\n      // Handle leading zeroes.\n      const chars = [...value];\n      let trailIndex = chars.findIndex((c) => c !== alphabet[0]);\n      trailIndex = trailIndex === -1 ? chars.length : trailIndex;\n      const leadingZeroes = Array(trailIndex).fill(0);\n      if (trailIndex === chars.length) return Uint8Array.from(leadingZeroes);\n\n      // From baseX to base10.\n      const tailChars = chars.slice(trailIndex);\n      let base10Number = 0n;\n      let baseXPower = 1n;\n      for (let i = tailChars.length - 1; i >= 0; i -= 1) {\n        base10Number += baseXPower * BigInt(alphabet.indexOf(tailChars[i]));\n        baseXPower *= baseBigInt;\n      }\n\n      // From base10 to bytes.\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      return Uint8Array.from(leadingZeroes.concat(tailBytes));\n    },\n    deserialize(buffer, offset = 0): [string, number] {\n      if (buffer.length === 0) return ['', 0];\n\n      // Handle leading zeroes.\n      const bytes = buffer.slice(offset);\n      let trailIndex = bytes.findIndex((n) => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, buffer.length];\n\n      // From bytes to base10.\n      let base10Number = bytes\n        .slice(trailIndex)\n        .reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n      // From base10 to baseX.\n      const tailChars = [];\n      while (base10Number > 0n) {\n        tailChars.unshift(alphabet[Number(base10Number % baseBigInt)]);\n        base10Number /= baseBigInt;\n      }\n\n      return [leadingZeroes + tailChars.join(''), buffer.length];\n    },\n  };\n};\n"],"names":["baseX","alphabet","base","length","baseBigInt","BigInt","description","fixedSize","maxSize","serialize","value","match","RegExp","InvalidBaseStringError","Uint8Array","chars","trailIndex","findIndex","c","leadingZeroes","Array","fill","from","tailChars","slice","base10Number","baseXPower","i","indexOf","tailBytes","unshift","Number","concat","deserialize","buffer","offset","bytes","n","repeat","reduce","sum","byte","join"],"mappings":"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"}