{"version":3,"file":"common.mjs","sources":["../../src/common.ts"],"sourcesContent":["import { base58 } from '@metaplex-foundation/umi-serializers-encodings';\nimport { InvalidPublicKeyError } from './errors';\n\n/**\n * The amount of bytes in a public key.\n * @category Signers and PublicKeys\n */\nexport const PUBLIC_KEY_LENGTH = 32;\n\n/**\n * Defines a public key as a base58 string.\n * @category Signers and PublicKeys\n */\nexport type PublicKey<TAddress extends string = string> = TAddress & {\n  readonly __publicKey: unique symbol;\n};\n\n/**\n * Defines a Program-Derived Address.\n *\n * It is a public key with the bump number that was used\n * to ensure the address is not on the ed25519 curve.\n *\n * @category Signers and PublicKeys\n */\nexport type Pda<\n  TAddress extends string = string,\n  TBump extends number = number\n> = [PublicKey<TAddress>, TBump] & { readonly __pda: unique symbol };\n\n/**\n * A Uint8Array that represents a public key.\n * @category Signers and PublicKeys\n */\nexport type PublicKeyBytes = Uint8Array & {\n  readonly __publicKeyBytes: unique symbol;\n};\n\n/**\n * Defines an object that has a public key.\n * @category Signers and PublicKeys\n */\nexport type HasPublicKey<TAddress extends string = string> = {\n  readonly publicKey: PublicKey<TAddress>;\n};\n\n/**\n * Defines an object that can be converted to a base58 public key.\n * @category Signers and PublicKeys\n */\nexport type LegacyWeb3JsPublicKey<TAddress extends string = string> = {\n  toBase58: () => TAddress;\n};\n\n/**\n * Defines all the possible inputs for creating a public key.\n * @category Signers and PublicKeys\n */\nexport type PublicKeyInput<TAddress extends string = string> =\n  | TAddress\n  | Uint8Array\n  | [TAddress, number]\n  | { publicKey: TAddress }\n  | LegacyWeb3JsPublicKey<TAddress>;\n\n/**\n * Defines all the possible safe inputs for creating a public key.\n * That is, they have already been validated to be or\n * to contain a valid public key.\n * @category Signers and PublicKeys\n */\nexport type SafePublicKeyInput<TAddress extends string = string> =\n  | PublicKey<TAddress>\n  | PublicKeyBytes\n  | Pda<TAddress>\n  | HasPublicKey<TAddress>\n  | LegacyWeb3JsPublicKey<TAddress>;\n\n/**\n * Creates a new public key from the given input.\n * @category Signers and PublicKeys\n */\nexport function publicKey<TAddress extends string>(\n  input: PublicKeyInput<TAddress>,\n  assertValidPublicKey?: true\n): PublicKey<TAddress>;\nexport function publicKey<TAddress extends string>(\n  input: SafePublicKeyInput<TAddress>,\n  assertValidPublicKey: false\n): PublicKey<TAddress>;\nexport function publicKey<TAddress extends string>(\n  input: PublicKeyInput<TAddress> | SafePublicKeyInput<TAddress>,\n  assertValidPublicKey: boolean = true\n): PublicKey<TAddress> {\n  const key = ((): string => {\n    if (typeof input === 'string') {\n      return input;\n    }\n    // HasPublicKey.\n    if (typeof input === 'object' && 'publicKey' in input) {\n      return input.publicKey;\n    }\n    // LegacyWeb3JsPublicKey.\n    if (typeof input === 'object' && 'toBase58' in input) {\n      return input.toBase58();\n    }\n    // Pda.\n    if (Array.isArray(input)) {\n      return input[0];\n    }\n    // PublicKeyBytes.\n    return base58.deserialize(input)[0];\n  })();\n\n  if (assertValidPublicKey) {\n    assertPublicKey(key);\n  }\n\n  return key as PublicKey<TAddress>;\n}\n\n/**\n * Creates the default public key which is composed of all zero bytes.\n * @category Signers and PublicKeys\n */\nexport const defaultPublicKey = () =>\n  '11111111111111111111111111111111' as PublicKey<'11111111111111111111111111111111'>;\n\n/**\n * Whether the given value is a valid public key.\n * @category Signers and PublicKeys\n */\nexport const isPublicKey = <TAddress extends string>(\n  value: TAddress\n): value is PublicKey<TAddress> => {\n  try {\n    assertPublicKey(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n/**\n * Whether the given value is a valid program-derived address.\n * @category Signers and PublicKeys\n */\nexport const isPda = <TAddress extends string, TBump extends number>(\n  value: [TAddress, TBump]\n): value is Pda<TAddress, TBump> =>\n  Array.isArray(value) &&\n  value.length === 2 &&\n  typeof value[1] === 'number' &&\n  isPublicKey(value[0]);\n\n/**\n * Ensures the given value is a valid public key.\n * @category Signers and PublicKeys\n */\nexport function assertPublicKey<TAddress extends string>(\n  value: TAddress\n): asserts value is PublicKey<TAddress> {\n  // Check value type.\n  if (typeof value !== 'string') {\n    throw new InvalidPublicKeyError(value, 'Public keys must be strings.');\n  }\n\n  // Check base58 encoding and byte length.\n  publicKeyBytes(value);\n}\n\n/**\n * Deduplicates the given array of public keys.\n * @category Signers and PublicKeys\n */\nexport const uniquePublicKeys = (publicKeys: PublicKey[]): PublicKey[] => [\n  ...new Set(publicKeys),\n];\n\n/**\n * Converts the given public key to a Uint8Array.\n * Throws an error if the public key is an invalid base58 string.\n * @category Signers and PublicKeys\n */\nexport const publicKeyBytes = (value: string): PublicKeyBytes => {\n  // Check string length to avoid unnecessary base58 encoding.\n  if (value.length < 32 || value.length > 44) {\n    throw new InvalidPublicKeyError(\n      value,\n      'Public keys must be between 32 and 44 characters.'\n    );\n  }\n\n  // Check base58 encoding.\n  let bytes: Uint8Array;\n  try {\n    bytes = base58.serialize(value);\n  } catch (error) {\n    throw new InvalidPublicKeyError(\n      value,\n      'Public keys must be base58 encoded.'\n    );\n  }\n\n  // Check byte length.\n  if (bytes.length !== PUBLIC_KEY_LENGTH) {\n    throw new InvalidPublicKeyError(\n      value,\n      `Public keys must be ${PUBLIC_KEY_LENGTH} bytes.`\n    );\n  }\n\n  return bytes as PublicKeyBytes;\n};\n\n/**\n * Converts the given public key to a base58 string.\n * @category Signers and PublicKeys\n * @deprecated Public keys are now represented directly as base58 strings.\n */\nexport const base58PublicKey = (key: PublicKeyInput): string => publicKey(key);\n\n/**\n * Whether the given public keys are the same.\n * @category Signers and PublicKeys\n * @deprecated Use `left === right` instead now that public keys are base58 strings.\n */\nexport const samePublicKey = (\n  left: PublicKeyInput,\n  right: PublicKeyInput\n): boolean => publicKey(left) === publicKey(right);\n"],"names":["PUBLIC_KEY_LENGTH","publicKey","input","assertValidPublicKey","key","toBase58","Array","isArray","base58","deserialize","assertPublicKey","defaultPublicKey","isPublicKey","value","error","isPda","length","InvalidPublicKeyError","publicKeyBytes","uniquePublicKeys","publicKeys","Set","bytes","serialize","base58PublicKey","samePublicKey","left","right"],"mappings":"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"}